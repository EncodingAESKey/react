
/*!
 * bundle
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Library version.
 */

exports.version = '0.2.3';

/**
 * Module dependencies.
 */

var jade = require('jade')
  , EventEmitter = require ('events').EventEmitter
  , exec = require('child_process').exec
  , fs = require ('fs')

 /**
 * Exports.
 */

exports.Bundle = Bundle;

exports.createBundle = function (opts) {
  return new Bundle(opts);
};

/**
 * Bundle constructor
 *
 * @api private
 */

function Bundle (opts) {
  // Bundle options
  this.options = {
      views: 'views/'
    , tmp: '/tmp'
    , gzip: 'zip'
    , engine: 'jade'
    , extension: 'html'
    , encoding: 'utf8'
  };

  merge(this.options, opts);

  // partials folder
  if (!opts.partials) {
    this.options.partials = this.options.views + 'partials/';
  }

  // initial properties
  this.generated = false;
  this.files = [];
  this.stack = [];

  // identifiers
  var id = this.id = 'bundle-' + Math.random().toString().substr(2);

  // @TODO: remains only for old version
  this.bundlePath = this.options.tmp + '/' + id + '/';
};

/**
 * add Event emission
 */

Bundle.prototype = new EventEmitter();

/**
 * Define a file
 *
 * @api private
 */

Bundle.prototype.file = function (name, params, fn) {
  if ('function' == typeof params) {
    fn = params;
    params = {};
  }

  // debug: adds file '%s' to `files`, name
  this.files.push({ name: name, params: params, rend: fn });
};

/**
 * Generates the structure in a tmp location and gzips it
 *
 * @param {Object} params
 * @param {Function} fn - callback
 * @api private
 */

Bundle.prototype.generate = function (params, fn) {
  // debug: Bundle - generating
  var self = this;

  if ('function' == typeof params) {
    fn = params;
    params = {};
  }

  // if this.generated = true calls immediately with this.file
  if (this.generated) {
    // debug: the bundle is already generated in %s, this.generated
    return fn(null, this.generated);
  } else {

    /**
     * process()
     * Process all partial templates (one per one) of files stack replacing the
     * partial identifier into the initial html source by the rendered html code
     *
     * @param {Object} tpl_params - main template params
     * @param {String} html - initial html code
     * @return {String} html
     * @api private
     */

    function process (tpl_params, html, fn) {
      var done = false
        , made = []

      while (!done) {
        (function(part) {
          if (made.indexOf(part.p) < 0) {
            made.push(part.p);

            // propagate template and partial params togheter to partial template
            merge(part.params, tpl_params);

            jade.renderFile(part.f, part.params || {}, function(err, _html) {
              if (err) return fn(err);
              // debug: partial %j rendered, part.f

              // partial element
              if (part.partial) {
                var regx = new RegExp(part.p, "g");
                html = html.replace(regx, _html);
              }

              self.stack.shift();
              done = !self.stack.length;
            });
          }
        })(self.stack[0])
      };

      return fn(null, html);
    };

    /**
     * partial() - rendering template function
     *
     * @param {String} path - partial file path
     * @param {Object} partial_params
     * @return {String} pid - partial identifier
     */

    function partial (path, partial_params, fn) {
      path = self.options.partials + path;
      partial_params = partial_params || {};

      // partial file name
      var file = path + '.jade';

      // create a partial identifier
      var pid = 'pid' + Math.random().toString().substr(2);

      // pass partial() function to partial template
      partial_params.partial = partial;

      // adds new partial to partials stacks
      self.stack.push({ p: pid, f: file, params: partial_params, partial: true });
      return pid;
    };

    // create bundle temporal folder
    createFolder(self.bundlePath, function(err) {
      if (err) return fn(err);

      initProcessFiles();
    });

    // renderind template files
    var fcounter = ftotal = self.files.length;
    function initProcessFiles () {
      for (var f = 0; f < self.files.length; f++) {
        (function(file) {
          // debug: start rendering %j file, file.name

          // rendering template callback function
          function render (template, tpl_params) {

            function renderTemplate (layout) {
              var tpl = self.options.views + template;
              tpl_params = tpl_params || {};

              // support partial rendering
              tpl_params.partial = partial;

              jade.renderFile(tpl, tpl_params, function(err, html) {
                if (err) return fn(err);

                if (layout) {
                  var regx = new RegExp(lid, "g");
                  html = layout.replace(regx, html);
                }

                process(tpl_params, html, function(err, htmlOut) {
                  if (err) return fn(err);
                  fileReady(file, htmlOut);
                });
              });
            };

            // layout support
            if (file.params.layout) {
              var layout = self.options.views + file.params.layout
                , lid = 'layoutid' + Math.random().toString().substr(2)
                , layout_params = { body: lid }

              delete file.params.layout;

              merge(layout_params, params);
              merge(layout_params, tpl_params);
              layout_params.partial = partial;

              jade.renderFile(layout, layout_params, function(err, html) {
                if (err) return fn(err);

                renderTemplate(html);
              });
            } else {
              renderTemplate();
            }
          };

          // simple text rendering support
          if ('string' == typeof file.rend) {
            fileReady(file, file.rend);
          } else {
            file.rend(params, render);
          }

        })(self.files[f]);
      }
    };

    /**
     * file ready
     */

    function fileReady (file, html) {
      file.params = file.params || {};
      var ext = '.' + (file.params.extension || self.options.extension)
        , filename = self.bundlePath + file.name + ext
      // debug: %j is ready to save, filename

      self.emit('fileReady', filename, html);
      saveFile(filename, html);
    };

    /**
     * save rendered file into tmp folder
     */

    function saveFile (filename, html) {
      // debug: saving %j file, filename
      var f = filename.match(/(.*\/).*\.\w*/)[1];

      createFolder(f, function(err) {
        if (err) return fn(err);
        // debug: folder %j, f

        fs.writeFile(filename, html, self.options.encoding, function(err) {
          if (err) return fn(err);
          // debug: %j wrote (%s/%s), filename, fcounter, ftotal

          --fcounter || generated(f);
        });
      });
    };

    function generated (folder) {
      // debug: bundle was generated in %s folder, folder
      self.generated = folder;
      return fn(null, folder)
    };

  }
};

/**
 * Generates a bundle and saves it to a file
 *
 * @api private
 */

Bundle.prototype.save = function (file, fn) {
  var self = this;

  // create zip pack
  function buildPackage (fn) {
    var zipname = self.bundlePath + 'bundle.zip'
      , zipCmd = '(cd ' + self.bundlePath + ' ; ' + 'zip -r ' + zipname + ' ./ )'

    exec(zipCmd, function (err, stdout, stderr) {
      if (err) return fn(err);
      // debug: %j package is done, zipname

      self.generated = zipname;
      return fn(null, zipname, self.bundlePath);
    });
  };

  buildPackage(function(err) {
    if (err) return fn(err);

    var f = file.match(/(.*\/).*\.\w*/) ? file.match(/(.*\/).*\.\w*/)[1] : '';

    createFolder(f, function (err) {
      if (err) return fn(err);

      // generate
      self.generate(function (err) {
        if (err) return fn(err);

        var mv = '(mv ' + self.generated + ' ' + escape(file) + ')';
        exec(mv, function (err, stdout, stderr) {
          if (err) return fn(err);

          var rm = '(rm -rf ' +  self.options.tmp + '/' + self.id + '/' + ')';
          exec(rm, function (err, stdout, stderr) {
            if (err) return fn(err);

            self.generated = false;
            return fn(null);
          });
        });
      });
    });
  });
}

/**
 * useful private functions
 */

 /**
 * createFolder() util method
 *
 * @api private
 */

function createFolder (path, fn) {
  if (!path) {
    return fn(null);
  }

  exec('mkdir -p ' + escape(path), function (err, stdout, stderr) {
    if (err) return fn(err);

    fn(null, path);
  });
 }

/**
 * Escape the given shell `str`.
 *
 * @param {String} arg
 * @return {String}
 */

function escape (str) {
  return '"' + String(str).replace(/"/g, '\\"') + '"';
}

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *     
 *     utils.merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api private
 */

function merge (a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};
